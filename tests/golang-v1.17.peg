newline        = "\n";

@lifted
eol            = (" " / "\t" / block_comment)* (";" / "\n" / !. / line_comment);

@lifted @squashed
whitespace = " " / "\t" / "\r" / "\n";

line_comment = "//" (!"\n" .)* ("\n" / !.);

@lifted @squashed
block_comment = "/*" (!"*/" .)* "*/";

@lifted
comment = line_comment / block_comment;

@lifted
ws = whitespace / line_comment / block_comment;

@lifted
linews = " " / "\t" / comment;

unicode_char   = !"\x0a" .;
unicode_letter = [\p{L}];
unicode_digit  = [\p{Nd}];

letter        = unicode_letter / "_";
decimal_digit = [0-9];
binary_digit  = [0-1];
octal_digit   = [0-7];
hex_digit     = [0-9] / [a-f] / [A-F];

@lifted
Keywords = "break" / "default" / "func" / "interface" / "select" /
            "case" / "defer" / "go" / "map" / "struct" /
            "chan" / "else" / "goto" / "package" / "switch" /
            "const" / "fallthrough" / "if" / "range" / "type" /
            "continue" / "for" / "import" / "return" / "var";

@squashed
identifier = !(Keywords !letter) letter (letter / unicode_digit)*;

@lifted
int_lit        = (binary_lit / octal_lit / hex_lit / decimal_lit) !("_" / "." / "p");
@squashed
decimal_lit    = "0" / ([1-9] ~ ("_"? decimal_digits)?);
@squashed
binary_lit     = i"0b" ~ "_"? binary_digits;
@squashed
octal_lit      = "0" i"o"? "_"? octal_digits;
@squashed
hex_lit        = i"0x" ~ "_"? hex_digits;

@squashed
decimal_digits = decimal_digit ("_"? decimal_digit)*;
@squashed
binary_digits  = binary_digit ("_"? binary_digit)*;
@squashed
octal_digits   = octal_digit ("_"? octal_digit)*;
@squashed
hex_digits     = hex_digit ("_"? hex_digit)*;

@lifted
float_lit         = (decimal_float_lit / hex_float_lit) ~ !letter;

@squashed
decimal_float_lit = decimal_digits "." ~ decimal_digits? decimal_exponent? /
                    decimal_digits decimal_exponent /
                    "." ~ decimal_digits decimal_exponent?;
@squashed
decimal_exponent  = i"e" ~ ("+" / "-")? decimal_digits;

@squashed
hex_float_lit     = i"0x" hex_mantissa hex_exponent;
@squashed
hex_mantissa      = "_"? hex_digits "." ~ hex_digits? /
                    "_"? hex_digits /
                    "." ~ hex_digits;
@squashed
hex_exponent      = i"p" ~ ("+" / "-")? decimal_digits;

@squashed
imaginary_lit = (decimal_float_lit / hex_float_lit / binary_lit / octal_lit / hex_lit / decimal_lit / decimal_digits) "i";

@squashed
rune_lit         = "'" ~ !"'" ( byte_value / unicode_value ) "'";
unicode_value    = little_u_value / big_u_value / escaped_char / unicode_char;
byte_value       = octal_byte_value / hex_byte_value;
octal_byte_value = "\\" octal_digit{3};

hex_byte_value   = "\\x" hex_digit{2};

little_u_value   = "\\u" hex_digit{4};

big_u_value      = "\\U" hex_digit{8};

escaped_char     = "\\" ( "a" / "b" / "f" / "n" / "r" / "t" / "v" / "\\" / "'" / "\"") ;

@lifted
string_lit             = raw_string_lit / interpreted_string_lit ;

@squashed
raw_string_lit         = "`" (!"`" (unicode_char / newline))* "`" ;

@squashed
interpreted_string_lit = "\"" (!"\"" (unicode_value / byte_value))* "\"";

Type      = TypeLit / "(" Type ")" / TypeName;
TypeName  = QualifiedIdent / identifier;
TypeLit   = ArrayType / SliceType / StructType / PointerType / FunctionType / InterfaceType / MapType / ChannelType ;

ArrayType   = "[" ArrayLength "]" ElementType ;
ArrayLength = Expression ;
ElementType = Type ;

SliceType = "[" "]" ElementType ;

StructType    = "struct" linews* "{" ~ ws* ((FieldDecl eol+ ws*)+ / FieldDecl)? ws* "}" ;
FieldDecl     = (IdentifierList linews+ Type / EmbeddedField) (linews* Tag)?;
EmbeddedField = "*"? linews* TypeName ;
Tag           = string_lit ;

PointerType = "*" BaseType ;
BaseType    = Type ;

FunctionType   = "func" Signature ;
Signature      = Parameters linews* Result? ;

Parameters     = "(" ~ (ws* ParameterList linews* ","?)? ws* ")" ;

ParameterList  = ParameterDecl (linews* "," ~ ws* ParameterDecl)* ;
ParameterDecl  = IdentifierList linews* "..."? linews* Type / "..."? linews* Type;
# ParameterDecl  = IdentifierList? linews* "..."? linews* Type ;

Result         = Type / Parameters;

InterfaceType      = "interface" linews* "{" ws* (( MethodSpec / InterfaceTypeName ) eol+ ws*)* ws* "}" ;
MethodSpec         = MethodName Signature ;
MethodName         = identifier ;
InterfaceTypeName  = TypeName ;

MapType     = "map" "[" KeyType "]" ElementType ;
KeyType     = Type ;

ChannelType = ( "chan" / "chan" linews* "<-" / "<-" linews* "chan" ) linews* ElementType ;

Block = "{" ~ ws* StatementList ws* "}" ;
StatementList = ((linews* Statement eol+)+ / Statement)?;

Declaration   = ConstDecl / TypeDecl / VarDecl ;
TopLevelDecl  = Declaration / MethodDecl / FunctionDecl ;

ConstDecl      = "const" ~ linews+ ( "(" ~ ws* (ConstSpec eol+ linews*)* ws* ")" / ConstSpec) ;
ConstSpec      = IdentifierList (linews* Type? linews* "=" linews* ExpressionList)? ;

IdentifierList = identifier (linews* "," ~ linews* identifier)* ;

@nonterminal
ExpressionList = Expression (linews* "," ws* Expression)*;

TypeDecl = "type" ~ linews+ ( TypeSpec / "(" ws* (TypeSpec eol+ ws*)* linews* ")" ) ;
TypeSpec = AliasDecl / TypeDef ;

AliasDecl = identifier linews* "=" linews* Type ;

TypeDef = identifier linews+ Type ;

VarDecl     = "var" ~ linews+ ( VarSpec / "(" (ws* VarSpec eol+ ws*)* linews* ")" ) ;
VarSpec     = IdentifierList ~ linews* ( Type (linews* "=" linews* ExpressionList)? / "=" linews* ExpressionList ) ;

ShortVarDecl = IdentifierList linews* ":=" ~ linews* ExpressionList ;

FunctionDecl = "func" ~ linews+ FunctionName ~ linews* Signature linews* FunctionBody? ;
FunctionName = identifier ;
@lifted
FunctionBody = Block ;

MethodDecl = "func" linews* Receiver ~ linews* MethodName linews* Signature linews* FunctionBody? ;
Receiver   = "(" ~ linews* (identifier linews+ Type / Type) linews* ")";
# Receiver   = Parameters .

@lifted
Operand     = Literal / OperandName / "(" Expression ")" ;
@lifted
Literal     = BasicLit / CompositeLit / FunctionLit ;
@lifted
BasicLit    = imaginary_lit / float_lit / int_lit / rune_lit / string_lit ;

@lifted
OperandName = QualifiedIdent / identifier;

QualifiedIdent = PackageName "." identifier ;

CompositeLit  = LiteralType LiteralValue ;
LiteralType   = StructType / "[" "..." "]" ElementType / ArrayType /
                SliceType / MapType / TypeName ;
LiteralValue  = "{" ~ ws* (ElementList linews* ","? ws*)? ws* "}" ;
ElementList   = KeyedElement ws* ("," ws* KeyedElement ws*)* ;
KeyedElement  = (Key linews* ":")? ws* Element ;
Key           = FieldName / Expression / LiteralValue ;
FieldName     = identifier ;
Element       = Expression / LiteralValue ;

FunctionLit = "func" ~ linews* Signature linews* FunctionBody ;

@nonterminal
PrimaryExpr = (Operand / Conversion / MethodExpr) (Selector / Index / Slice / TypeAssertion / Arguments)*;

Selector       = "." identifier ;
Index          = "[" ws* Expression ws* "]" ;
Slice          = "[" ws* Expression? ws* ":" ws* Expression? ws* "]" /
                 "[" ws* Expression? ws* ":" ws* Expression ws* ":" ws* Expression ws* "]" ;
TypeAssertion  = "." "(" ws* Type ws* ")" ;
Arguments      = "(" ~ ws* (( ExpressionList / Type (linews* "," ws* ExpressionList)? ) linews* "..."? linews* ","? )? ws* ")" ;

MethodExpr    = ReceiverType "." MethodName ;
ReceiverType  = Type ;

@nonterminal 
Expression = UnaryExpr (linews* binary_op ~ ws* UnaryExpr)*;
# Expression = UnaryExpr | Expression binary_op Expression .

@nonterminal @scoped
UnaryExpr  = unary_op* PrimaryExpr;
# UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

@nonterminal
UnambiguousExpression = UnambiguousUnaryExpr (linews* binary_op ~ ws* UnambiguousUnaryExpr)*;
@nonterminal
UnambiguousUnaryExpr  = unary_op* UnambiguousPrimaryExpr;
@nonterminal
UnambiguousPrimaryExpr = (UnambiguousOperand / Conversion / MethodExpr) (Selector / Index / Slice / TypeAssertion / Arguments)*;
UnambiguousOperand = BasicLit / FunctionLit / OperandName / "(" linews* Expression linews* ")";

binary_op  = "||" / "&&" / (add_op !"=") / (mul_op !"=") / rel_op;
rel_op     = "==" / "!=" / "<=" / "<" !"<" / ">=" / ">" !">";
add_op     = "+" !"+" / "-" !"-" / "|" / "^" ;
mul_op     = "*" / "/" / "%" / "<<" / ">>" / "&^" / "&" ;

unary_op   = "+" / "-" / "!" / "^" / "*" / "&" / "<-" ;

Conversion = Type linews* "(" linews* Expression linews* ","? linews* ")" ;

@lifted
Statement =
	IfStmt / ReturnStmt / ForStmt / Declaration / LabeledStmt /
	GoStmt / BreakStmt / ContinueStmt / GotoStmt /
	FallthroughStmt / SwitchStmt / SelectStmt /
	DeferStmt / Block / SimpleStmt;

@lifted
SimpleStmt = SendStmt / IncDecStmt / Assignment / ShortVarDecl / ExpressionStmt;

EmptyStmt = &. ;

LabeledStmt = Label linews* ":" ws* Statement ;
Label       = identifier ;

ExpressionStmt = Expression ;

SendStmt = Channel linews* "<-" ws* Expression ;
Channel  = Expression ;

IncDecStmt = Expression linews* ( "++" / "--" );

Assignment = ExpressionList linews* assign_op linews* ExpressionList ;

assign_op = (add_op / mul_op)? "=" ;

IfStmt = "if" ~ linews+ (SimpleStmt ";")? linews* UnambiguousExpression linews* Block (ws* "else" ~ ws* ( IfStmt / Block ))? ;

SwitchStmt = TypeSwitchStmt / ExprSwitchStmt;

ExprSwitchStmt = "switch" linews+ (SimpleStmt linews* ";"?)? linews* UnambiguousExpression? ~ linews* "{" (ws* ExprCaseClause)* ws* "}" ;
ExprCaseClause = ExprSwitchCase linews* ":" ws* StatementList ;
ExprSwitchCase = "case" linews+ ~ ExpressionList / "default" ;

TypeSwitchStmt  = "switch" linews+ (SimpleStmt linews* ";")? linews* TypeSwitchGuard ~ linews* "{" (ws* TypeCaseClause)* ws* "}" ;
TypeSwitchGuard = (identifier linews* ":=")? linews* PrimaryExpr linews* "." linews* "(" linews* "type" linews* ")" ;
TypeCaseClause  = TypeSwitchCase linews* ":" ws* StatementList ;
TypeSwitchCase  = "case" linews+ ~ TypeList / "default" ;
TypeList        = Type (linews* "," linews* Type)* ;

ForStmt = "for" linews+ ~ (RangeClause / ForClause / Condition)? linews* Block ;
Condition = UnambiguousExpression ;

ForClause = InitStmt? linews* ";" linews* Condition? linews* ";" linews* PostStmt?  ;
InitStmt = SimpleStmt ;
PostStmt = SimpleStmt ;

RangeClause = (ExpressionList linews* "=" / IdentifierList linews* ":=")? linews* "range" linews+ Expression;


GoStmt = "go" linews+ Expression ;

SelectStmt = "select" linews* "{" ws* CommClause*  ws* "}" ;
CommClause = CommCase ":" StatementList ;
CommCase   = "case" linews+ ( SendStmt / RecvStmt ) / "default" ;
RecvStmt   = (ExpressionList linews* "=" / IdentifierList linews* ":=")? linews* RecvExpr ;
RecvExpr   = Expression ;

ReturnStmt = "return" ~ (linews* ExpressionList)? ;

BreakStmt = "break" (linews+ Label)?  ;


ContinueStmt = "continue" (linews+ Label)? ;


GotoStmt = "goto" linews+ Label ;

FallthroughStmt = "fallthrough" ;

DeferStmt = "defer" linews+ Expression ;

SourceFile       = &. ws* PackageClause eol+ (ws* ImportDecl eol+)* ws* (TopLevelDecl eol+ ws*)* ws* !.;

PackageClause  = "package" ~ linews+ PackageName ;
PackageName    = identifier ;

ImportDecl       = "import" linews* ~ (  "(" ws* (ImportSpec eol+ linews*)* ws* ")" / ImportSpec) ;
ImportSpec       = ("." / PackageName)? linews* ImportPath ;

@squashed
ImportPath       = string_lit ;

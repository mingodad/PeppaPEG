newline        = "\n";

@lifted
eol            = (" " / "\t")* (";" / "\n" / !. / line_comment);

@lifted @squashed
whitespace = " " / "\t" / "\r" / "\n";

line_comment = "//" (!"\n" .)* ("\n" / !.);

@lifted @squashed
block_comment = "/*" (!"*/" .)* "*/";

@lifted
comment = line_comment / block_comment;

@lifted
ws = whitespace / line_comment / block_comment;

@lifted
linews = " " / "\t" / comment;

unicode_char   = !"\x0a" .;
unicode_letter = [\p{L}];
unicode_digit  = [\p{Nd}];

letter        = unicode_letter / "_";
decimal_digit = [0-9];
binary_digit  = [0-1];
octal_digit   = [0-7];
hex_digit     = [0-9] / [a-f] / [A-F];

@lifted
Keywords = "break" / "default" / "func" / "interface" / "select" /
            "case" / "defer" / "go" / "map" / "struct" /
            "chan" / "else" / "goto" / "package" / "switch" /
            "const" / "fallthrough" / "if" / "range" / "type" /
            "continue" / "for" / "import" / "return" / "var";

@squashed
identifier = !(Keywords !letter) letter (letter / unicode_digit)*;

@lifted
int_lit        = (binary_lit / octal_lit / hex_lit / decimal_lit) !("_" / "." / "p");
@squashed
decimal_lit    = "0" / ([1-9] ~ ("_"? decimal_digits)?);
@squashed
binary_lit     = i"0b" ~ "_"? binary_digits;
@squashed
octal_lit      = "0" i"o"? "_"? octal_digits;
@squashed
hex_lit        = i"0x" ~ "_"? hex_digits;

@squashed
decimal_digits = decimal_digit ("_"? decimal_digit)*;
@squashed
binary_digits  = binary_digit ("_"? binary_digit)*;
@squashed
octal_digits   = octal_digit ("_"? octal_digit)*;
@squashed
hex_digits     = hex_digit ("_"? hex_digit)*;

@lifted
float_lit         = (decimal_float_lit / hex_float_lit) ~ !letter;

@squashed
decimal_float_lit = decimal_digits "." ~ decimal_digits? decimal_exponent? /
                    decimal_digits decimal_exponent /
                    "." ~ decimal_digits decimal_exponent?;
@squashed
decimal_exponent  = i"e" ~ ("+" / "-")? decimal_digits;

@squashed
hex_float_lit     = i"0x" hex_mantissa hex_exponent;
@squashed
hex_mantissa      = "_"? hex_digits "." ~ hex_digits? /
                    "_"? hex_digits /
                    "." ~ hex_digits;
@squashed
hex_exponent      = i"p" ~ ("+" / "-")? decimal_digits;

@squashed
imaginary_lit = (decimal_float_lit / hex_float_lit / binary_lit / octal_lit / hex_lit / decimal_lit / decimal_digits) "i";

@squashed
rune_lit         = "'" ~ !"'" ( byte_value / unicode_value ) "'";
unicode_value    = little_u_value / big_u_value / escaped_char / unicode_char;
byte_value       = octal_byte_value / hex_byte_value;
octal_byte_value = "\\" octal_digit{3};

hex_byte_value   = "\\x" hex_digit{2};

little_u_value   = "\\u" hex_digit{4};

big_u_value      = "\\U" hex_digit{8};

escaped_char     = "\\" ( "a" / "b" / "f" / "n" / "r" / "t" / "v" / "\\" / "'" / "\"") ;

@lifted
string_lit             = raw_string_lit / interpreted_string_lit ;

@squashed
raw_string_lit         = "`" (!"`" (unicode_char / newline))* "`" ;

@squashed
interpreted_string_lit = "\"" (!"\"" (unicode_value / byte_value))* "\"";

Type      = TypeLit / "(" Type ")" / TypeName;
TypeName  = QualifiedIdent / identifier;
TypeLit   = ArrayType / StructType / PointerType / FunctionType / InterfaceType / SliceType / MapType / ChannelType ;

ArrayType   = "[" ArrayLength "]" ElementType ;
ArrayLength = Expression ;
ElementType = Type ;

SliceType = "[" "]" ElementType ;

StructType    = "struct" "{" ( FieldDecl ";"? )* "}" ;
FieldDecl     = (IdentifierList Type / EmbeddedField) Tag? ;
EmbeddedField = "*"? TypeName ;
Tag           = string_lit ;

PointerType = "*" BaseType ;
BaseType    = Type ;

FunctionType   = "func" Signature ;
Signature      = Parameters Result? ;

Parameters     = "(" ~ (linews* ParameterList linews* ","?)? linews* ")" ;

ParameterList  = ParameterDecl (linews* "," ~ linews* ParameterDecl)* ;
ParameterDecl  = IdentifierList linews* "..."? linews* Type / "..."? linews* Type;
# ParameterDecl  = IdentifierList? linews* "..."? linews* Type ;

Result         = Type / ResultParameters;
ResultParameters = "(" ~ (ResultParameterList ","?)? ")" ;
@lifted
ResultParameterList  = ResultParameterDecl ("," ~ ResultParameterDecl)* ;
ResultParameterDecl  = IdentifierList "..."? Type / "..."? Type;

InterfaceType      = "interface" "{" (( MethodSpec / InterfaceTypeName ) ";"?)* "}" ;
MethodSpec         = MethodName Signature ;
MethodName         = identifier ;
InterfaceTypeName  = TypeName ;

MapType     = "map" "[" KeyType "]" ElementType ;
KeyType     = Type ;

ChannelType = ( "chan" / "chan" "<-" / "<-" "chan" ) ElementType ;

Block = "{" ~ ws* StatementList? ws* "}" ;
StatementList = (Statement linews* eol)+ ;

Declaration   = ConstDecl / TypeDecl / VarDecl ;
TopLevelDecl  = Declaration / MethodDecl / FunctionDecl ;

ConstDecl      = "const" ~ ( "(" ~ (ConstSpec ";"?)* ")" / ConstSpec) ;
ConstSpec      = IdentifierList (Type? "=" ExpressionList)? ;

@scoped
IdentifierList = identifier ("," ~ identifier)* ;
@scoped @nonterminal
ExpressionList = Expression (linews* "," ~ linews* Expression)*;

TypeDecl = "type" ( TypeSpec / "(" (TypeSpec ";"?)* ")" ) ;
TypeSpec = AliasDecl / TypeDef ;

AliasDecl = identifier "=" Type ;

TypeDef = identifier Type ;

VarDecl     = "var" ( VarSpec / "(" (VarSpec ";"?)* ")" ) ;
VarSpec     = IdentifierList ( Type ("=" ExpressionList)? / "=" ExpressionList ) ;

ShortVarDecl = IdentifierList ":=" ExpressionList ;

FunctionDecl = "func" linews+ FunctionName ~ linews* Signature linews* FunctionBody? ;
FunctionName = identifier ;
@lifted
FunctionBody = Block ;

MethodDecl = "func" Receiver MethodName ~ Signature FunctionBody? ;
Receiver   = "(" identifier Type ")" / "(" Type ")";
# Receiver   = Parameters .

@lifted
Operand     = Literal / OperandName / "(" Expression ")" ;
@lifted
Literal     = BasicLit / CompositeLit / FunctionLit ;
@lifted
BasicLit    = imaginary_lit / float_lit / int_lit / rune_lit / string_lit ;
@lifted
OperandName = QualifiedIdent / identifier;

QualifiedIdent = PackageName "." identifier ;

CompositeLit  = LiteralType LiteralValue ;
LiteralType   = StructType / ArrayType / "[" "..." "]" ElementType /
                SliceType / MapType / TypeName ;
LiteralValue  = "{" (ElementList ","?)? "}" ;
ElementList   = KeyedElement ("," KeyedElement)* ;
KeyedElement  = (Key ":")? Element ;
Key           = FieldName / Expression / LiteralValue ;
FieldName     = identifier ;
Element       = Expression / LiteralValue ;

FunctionLit = "func" ~ Signature FunctionBody ;

@nonterminal
PrimaryExpr = (Operand / Conversion / MethodExpr) (Selector / Index / Slice / TypeAssertion / Arguments)*;

Selector       = "." identifier ;
Index          = "[" Expression "]" ;
Slice          = "[" Expression? ":" Expression? "]" /
                 "[" Expression? ":" Expression ":" Expression "]" ;
TypeAssertion  = "." "(" Type ")" ;
Arguments      = "(" linews* (( ExpressionList / Type (linews* "," linews* ExpressionList)? ) linews* "..."? linews* ","? )? linews* ")" ;

MethodExpr    = ReceiverType "." MethodName ;
ReceiverType  = Type ;

@nonterminal 
Expression = UnaryExpr (linews* binary_op ~ ws* UnaryExpr)*;
# Expression = UnaryExpr | Expression binary_op Expression .

@nonterminal @scoped
UnaryExpr  = unary_op* PrimaryExpr;
# UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

@nonterminal
UnambiguousExpression = UnambiguousUnaryExpr (binary_op ~ UnambiguousUnaryExpr)*;
@nonterminal
UnambiguousUnaryExpr  = unary_op* UnambiguousPrimaryExpr;
@nonterminal
UnambiguousPrimaryExpr = (UnambiguousOperand / Conversion / MethodExpr) (Selector / Index / Slice / TypeAssertion / Arguments)*;
UnambiguousOperand = BasicLit / FunctionLit / OperandName / "(" Expression ")";

binary_op  = "||" / "&&" / add_op / mul_op / rel_op;
rel_op     = "==" / "!=" / "<" / "<=" / ">" / ">=" ;
add_op     = "+" / "-" / "|" / "^" ;
mul_op     = "*" / "/" / "%" / "<<" / ">>" / "&" / "&^" ;

unary_op   = "+" / "-" / "!" / "^" / "*" / "&" / "<-" ;

Conversion = Type "(" Expression ","? ")" ;

@lifted
Statement =
	IfStmt / ReturnStmt / ForStmt / Declaration / LabeledStmt /
	GoStmt / BreakStmt / ContinueStmt / GotoStmt /
	FallthroughStmt / SwitchStmt / SelectStmt /
	DeferStmt / Block / SimpleStmt;

@lifted
SimpleStmt = SendStmt / IncDecStmt / Assignment / ShortVarDecl / ExpressionStmt;

EmptyStmt = &. ;

LabeledStmt = Label ":" Statement ;
Label       = identifier ;

ExpressionStmt = Expression ;

SendStmt = Channel "<-" Expression ;
Channel  = Expression ;

IncDecStmt = Expression ( "++" / "--" );

Assignment = ExpressionList assign_op ExpressionList ;

assign_op = (add_op / mul_op)? "=" ;

IfStmt = "if" ~ (SimpleStmt ";")? UnambiguousExpression Block ("else" ( IfStmt / Block ))? ;

SwitchStmt = ExprSwitchStmt / TypeSwitchStmt ;

ExprSwitchStmt = "switch" (SimpleStmt ";"?)?  UnambiguousExpression?  "{" ExprCaseClause*  "}" ;
ExprCaseClause = ExprSwitchCase ":" StatementList ;
ExprSwitchCase = "case" ExpressionList / "default" ;

TypeSwitchStmt  = "switch" (SimpleStmt ";"?)? TypeSwitchGuard "{" TypeCaseClause*  "}" ;
TypeSwitchGuard = (identifier ":=")? PrimaryExpr "." "(" "type" ")" ;
TypeCaseClause  = TypeSwitchCase ":" StatementList ;
TypeSwitchCase  = "case" TypeList / "default" ;
TypeList        = Type ("," Type)* ;

ForStmt = "for" ~ (RangeClause / ForClause / Condition)? Block ;
Condition = UnambiguousExpression ;

ForClause = InitStmt?  ";" Condition?  ";" PostStmt?  ;
InitStmt = SimpleStmt ;
PostStmt = SimpleStmt ;

RangeClause = (ExpressionList "=" / IdentifierList ":=")? "range" Expression;


GoStmt = "go" ws+ Expression ;

SelectStmt = "select" "{" CommClause*  "}" ;
CommClause = CommCase ":" StatementList ;
CommCase   = "case" ( SendStmt / RecvStmt ) / "default" ;
RecvStmt   = (ExpressionList "=" / IdentifierList ":=")? RecvExpr ;
RecvExpr   = Expression ;


ReturnStmt = "return" ws+ ExpressionList? ;


BreakStmt = "break" ws+ Label?  ;


ContinueStmt = "continue" ws+ Label? ;


GotoStmt = "goto" ws+ Label ;

FallthroughStmt = "fallthrough" ;

DeferStmt = "defer" Expression ;

SourceFile       = &. ws* PackageClause eol+ (ws* ImportDecl eol+)* (ws* TopLevelDecl eol+)* ws* !.;

PackageClause  = "package" ~ linews+ PackageName ;
PackageName    = identifier ;

ImportDecl       = "import" linews* ~ (  "(" (linews* ImportSpec eol+)* ")" / ImportSpec) ;
ImportSpec       = ("." / PackageName)? ImportPath ;

@squashed
ImportPath       = string_lit ;
